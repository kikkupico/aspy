refer lib

permute [] = [ [] ]
permute :l =
  other-perms-of :x = permute ( l without x )
  [ it followed-by-each [ other-perms-of it ] ] each of l







refer lib

permute [] = [ [] ]
permute :l =
  other-perms-of :x = 2 times ( l without x )
  case
    length of l == 1
    [ l ]
    -true-
    [ it followed-by-each [ other-perms-of it ] ] each of l 
      fold left []
        [ _ + _ ]

permute ( 1 to 2 )



DISCUSSION

why does the prog below return nested array ?

refer lib

it = _

n = [ 1 2 3 ]
l = [ a b c ]

:a tuple :b = a :: ( b :: [] )

abc :c = l map* [ c tuple it ]

n map* [ abc it ]

