-true- and :q = q
-false- and :q = -false-

-true- or :q = -true-
-false- or :q = q

not -true- = -false-
not -false- = -true-

item 0 of :l = head l
item :n of :l = item ( n - 1 ) of ( tail l )  

empty :l ? = l == []

:n times :x =
  case
    n == 0
    ()
    n == 1
    [ x ]
    -true-
    x :: ( ( n - 1 ) times x )

:p to :q = case
  p == q
  p  ( :: [] )
  -true-
  p ( :: ( ( p + 1 ) to q ) )

:p ++ :q =
  case
    p == []
    q ( :: [] )
    tail p == []
    head p ( :: ( q ( :: [] ) ) )
    -true-
    head p ( :: ( tail p ++ q ) )

:p , :q =
  case
    word p ?
    p ( :: ( q ( :: [] ) ) )
    -true-
    p ++ q

length of :l =
  case
    word l ?
    0
    l == []
    0
    -true-
    1 + ( length of ( tail l ) )


:x -in- :l =
  case
    l == []
    -false-
    head l == x
    -true-
    -true-
    x -in- ( tail l )


[ [ = partial-list 1 ( [] :: ( [] :: [] ) )
[ :x = partial-list 0 ( ( x ( :: [] ) ) :: [] )
partial-list 0  :l ]  = head l
partial-list 0 :l [   = partial-list 1 ( [] :: l )
partial-list :n :l [  = partial-list ( n + 1 ) ( [] :: l )
partial-list :n :l ]  = partial-list ( n - 1 ) ( ( item 1 of l ++ ( head l ) ) ( :: ( tail ( tail l ) ) ) )
partial-list 0 :l :x  = partial-list 0 ( ( ( head l ) ++ x ) ( :: [] ) )
partial-list :n :l :x = partial-list n ( ( ( head l ) ++ x ) ( :: ( tail l ) ) )


fill :pattern with :values =
  case 
    pattern == []
    ()
    -true-
    case 
      head pattern ( == it )
      case        
        tail values == []
        head values ( fill ( tail pattern ) with values )
        -true-
        head values ( fill ( tail pattern ) with ( tail values ) )
      -true- 
      head pattern ( fill ( tail pattern ) with values )

:l map :pattern =
  case
    l == []
    []
    pattern == []
    l
    -true-
    ( fill pattern with ( ( head l ) ( :: [] ) ) ) ( :: ( ( tail l ) map pattern ) )


:list filter :pattern =
  case
    list == []
    []    
    fill pattern with ( ( head list ) :: [] ) == -true-
    ( head list ) :: ( tail list filter pattern )
    -true-
    tail list filter pattern


:list fold left :init :pattern =
  case
    list == []
    init
    -true-    
    tail list fold left ( fill pattern with ( [ init ( head list ) ] ) ) pattern


:list fold right :pattern :init =
  case
    list == []
    init
    -true-    
    tail list fold right ( fill pattern with ( [ ( head list ) init ] ) ) pattern


index* of :x in :l :n =
  case
    l == []
    -nil-
    head l == x
    n
    -true-
    index* of x in ( tail l ) ( n + 1 )

index of :x in :l = index* of x in l 0


quicksort [] = []
quicksort :list =
  pivot = head list
  rest = tail list
  lesser = quicksort ( rest filter ( [ _ <= pivot ] ) )
  greater = quicksort ( rest filter ( [ _ > pivot ] ) )
  lesser + ( [ pivot ] ) + greater

:x ^ 0 = 1
:x ^ :n = ( 0 to ( n - 1 ) ) fold left 1 ( [ _ * x ] )

:a : :b = [ a b ]

:q func* :f [ [ = q partial-func* f 1 ( [] :: ( [] :: [] ) )
:q func* :f [ :x = q partial-func* f 0 ( ( x ( :: [] ) ) :: [] )
:q partial-func* :f 0 :l ]  = q f ( head l )
:q partial-func* :f 0 :l [   = q partial-func* f 1 ( [] :: l )
:q partial-func* :f :n :l [  = q partial-func* f ( n + 1 ) ( [] :: l )
:q partial-func* :f :n :l ]  = q partial-func* f ( n - 1 ) ( ( item 1 of l ++ ( head l ) ) ( :: ( tail ( tail l ) ) ) )
:q partial-func* :f 0 :l :x  = q partial-func* f 0 ( ( ( head l ) ++ x ) ( :: [] ) )
:q partial-func* :f :n :l :x = q partial-func* f n ( ( ( head l ) ++ x ) ( :: ( tail l ) ) )

:q *func* :f { { = q *partial-func* f 1 ( [] :: ( [] :: [] ) )
:q *func* :f { :x = q *partial-func* f 0 ( ( x ( :: [] ) ) :: [] )
:q *partial-func* :f 0 :l }  = q f ( head l )
:q *partial-func* :f 0 :l {  = q *partial-func* f 1 ( [] :: l )
:q *partial-func* :f :n :l {  = q *partial-func* f ( n + 1 ) ( [] :: l )
:q *partial-func* :f :n :l }  = q *partial-func* f ( n - 1 ) ( ( item 1 of l ++ ( head l ) ) ( :: ( tail ( tail l ) ) ) )
:q *partial-func* :f 0 :l :x  = q *partial-func* f 0 ( ( ( head l ) ++ x ) ( :: [] ) )
:q *partial-func* :f :n :l :x = q *partial-func* f n ( ( ( head l ) ++ x ) ( :: ( tail l ) ) )

:l map* = l func* map
:l filter* = l func* filter

:l *map* = l *func* map

:a followed by :b =
  case
    b == []
    a :: []
    word b ?
    a :: ( b :: [] )
    -true-
    a :: b


unroll :l =
  case
    l == []
    ()
    word ( head l ) ?
    case
      head l == list
      head ( tail l ) ( unroll ( tail ( tail l ) ) )
      -true-
      ( head l ) ( unroll ( tail l ) )
    -true-
    unroll ( head l ) ( unroll ( tail l ) )

unroll-bound :x :l =
  case
    l == []
    ()
    word ( head l ) ?
    case
      head l == list
      head ( tail l ) ( unroll-bound x ( tail ( tail l ) ) )
      head l == it
      x ( unroll-bound x ( tail l ) )
      -true-
      head l ( unroll-bound x ( tail l ) )
    -true-
    unroll-bound x ( head l ) ( unroll-bound x ( tail l ) )


unroll-bound-p :v :x :l =
  case
    l == []
    ()
    word ( head l ) ?
    case
      head l == list
      head ( tail l ) ( unroll-bound-p v x ( tail ( tail l ) ) )
      head l == v
      x ( unroll-bound-p v x ( tail l ) )
      -true-
      ( head l ) ( unroll-bound-p v x ( tail l ) )
    -true-
    unroll-bound-p v x ( head l ) ( unroll-bound-p v x ( tail l ) )


:p each of :l =
  case
    l == []
    []
    p == []
    l
    -true-
    unroll-bound ( head l ) p :: ( p each of ( tail l ) )


:x not= :y = not ( x == y )
:l without :x = l filter* [ _ not= x ]
:x followed-by-each :l = [ x followed by it ] each of l


:p cartesian* :q =
  case
    p == []
    []
    q == []
    []
    -true-
    head p followed by ( head q ) followed by ( ( tail p ) cartesian* ( tail q ) )


:exp in :l -where :cond =
  case
    l == []
    []
    unroll-bound ( head l ) cond
    unroll-bound ( head l ) exp
    -true-
    exp in ( tail l ) -where cond

:exp in :q where [ [ = exp in q partial-where 1 ( [] :: ( [] :: [] ) )
:exp in :q where [ :x = exp in q partial-where 0 ( ( x ( :: [] ) ) :: [] )
:exp in :q partial-where 0 :l ]  = exp in q -where ( head l )
:exp in :q partial-where 0 :l [   = exp in q partial-where 1 ( [] :: l )
:exp in :q partial-where :n :l [  = exp in q partial-where ( n + 1 ) ( [] :: l )
:exp in :q partial-where :n :l ]  = exp in q partial-where ( n - 1 ) ( ( item 1 of l ++ ( head l ) ) ( :: ( tail ( tail l ) ) ) )
:exp in :q partial-where 0 :l :x  = exp in q partial-where 0 ( ( ( head l ) ++ x ) ( :: [] ) )
:exp in :q partial-where :n :l :x = exp in q partial-where n ( ( ( head l ) ++ x ) ( :: ( tail l ) ) )


:p for each :v in :l =
  v = head l
  case
    l == []
    []
    -true-
    unroll p :: ( p for each v in ( tail l ) )
