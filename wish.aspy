super map (partially done)
1 to 10
  take 5
  filter [ _ > 5 ]
  map [ 10 + _ ]
  reduce 0 [ _ + _ ]



multi level map ;  [ ] based array within map

it = _

n = [ 1 2 3 ]
l = [ a b c ]

:a tuple :b = a :: ( b :: [] )

abc :c = l map* [ c tuple it ]

n map [ l map [ [ it_n it_l ] ] ]




alt map ?

1 to 10 map { it + 10 }
n map { l map { [ it_n it_l ] } }



easy case

:p ++ :q = case
  p == [] ?
    q ( :: [] )
  tail p == [] ?
    head p ( :: ( q ( :: [] ) ) )
  otherwise
    head p ( :: ( tail p ++ q ) )

:p ++ :q = case
  p == [] ?
  - q ( :: [] )
  tail p == [] ?
  - head p ( :: ( q ( :: [] ) ) )
  otherwise
  - head p ( :: ( tail p ++ q ) )

:p ++ :q = 
  if p == []
    q ( :: [] )
  else if p == []
    head p ( :: ( q ( :: [] ) ) )
  else
  - head p ( :: ( tail p ++ q ) )

case
  name ?
    pop
      pep
    kik
      kek
    aru
      bisk ?
        busk
          bask
        husk
          pupp





nested pattern matching
???

count-leaves :l =
  case
    l == []
    0
    word l ?
    1
    -true-
    count-leaves ( head l ) +
      count-leaves ( tail l )


count-leaves :l = 
  case
    l == []
      0
    word l ?
      1
    -true-
      count-leaves ( head l ) +
        count-leaves ( tail l )

