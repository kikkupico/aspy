refer lib

1 to 10
  fold right []
    [ it :: it ]
returns wrongly, ([2, 3, 4, 5, 6, 7, 8, 9, 10], 'fold', 'right', '-nil-')




IMP: below prog doesn't work as expect; major matching logic revamp needed
4 2 3 + 7

IMP: unroll-bound not working for some fns


refer lib

fizzbuzzer :x =
  case
    x + 15 == 0
    fizzbuzz
    x + 5 == 0
    buzz
    x + 3 == 0
    fizz
    -true-
    x

even :n = 1 + n

unroll-bound 5 ( [ even it ] )





map map* not working with prefix style functions (eg: add _ _ )

assignment not working in case within functions

will this work?

a :b :c = b + c
a :b :c :d = b + c + d

filter very slow

variables are not substituted in function definitions

DESIGN ISSUE :

:x to :y is defined;
"ways to make change" is matched with :x to :y
( make typed pattern matching? )


:: ANALYZING... ::


:: RESOLVED ::

buggy map

assigning values to case within not working within function
- parans not added correctly
-- doesn't exist in multiret

-- '~' remains in scope; 'x' doesn't -- 

:a , :b =
  x = 1
  :a ~ :b = a + 1
  a ~ b

1 , 2
1 ~ 2
x

 fix 1 ( failed) was using append for function defs; append mutated existing object; changing this leads to infinite recursion

  doesn't exist in multiret

nested case not working ?
resolved by slightly disambiguating eval returns